const fs = require('fs').promises;
const path = require('path');
const logger = require('./logger');

const NAMESPACE_FILE = path.join(__dirname, '../namespace.js');

/**
 * Namespace Manager
 * Manages RAG namespace storage in local file (namespace.js)
 */
class NamespaceManager {
  /**
   * Get namespace from storage file
   * @returns {Promise<string|null>} Namespace string or null if not set
   */
  async getNamespace() {
    try {
      // Read the namespace.js file
      const fileContent = await fs.readFile(NAMESPACE_FILE, 'utf8');
      
      // Extract namespace using regex (safer than eval)
      const namespaceMatch = fileContent.match(/namespace:\s*['"]([^'"]+)['"]/);
      if (namespaceMatch && namespaceMatch[1]) {
        return namespaceMatch[1];
      }
      
      // Fallback: try to require the module
      try {
        const namespaceModule = require(NAMESPACE_FILE);
        if (namespaceModule && namespaceModule.namespace) {
          return namespaceModule.namespace;
        }
      } catch (requireError) {
        logger.debug('Could not require namespace module:', requireError.message);
      }
      
      return null;
    } catch (error) {
      if (error.code === 'ENOENT') {
        // File doesn't exist yet, return null
        logger.debug('Namespace file does not exist yet');
        return null;
      }
      logger.warn('Error reading namespace file:', error.message);
      return null;
    }
  }

  /**
   * Get index name from storage file
   * @returns {Promise<string|null>} Index name or null if not set
   */
  async getIndexName() {
    try {
      const fileContent = await fs.readFile(NAMESPACE_FILE, 'utf8');
      
      const indexMatch = fileContent.match(/indexName:\s*['"]([^'"]+)['"]/);
      if (indexMatch && indexMatch[1]) {
        return indexMatch[1];
      }
      
      try {
        const namespaceModule = require(NAMESPACE_FILE);
        if (namespaceModule && namespaceModule.indexName) {
          return namespaceModule.indexName;
        }
      } catch (requireError) {
        logger.debug('Could not require namespace module:', requireError.message);
      }
      
      return null;
    } catch (error) {
      if (error.code === 'ENOENT') {
        return null;
      }
      logger.warn('Error reading index name from file:', error.message);
      return null;
    }
  }

  /**
   * Save namespace to storage file
   * @param {string} namespace - Namespace to save
   * @param {string} indexName - Index name to save
   * @returns {Promise<boolean>} True if saved successfully
   */
  async saveNamespace(namespace, indexName) {
    try {
      if (!namespace || typeof namespace !== 'string') {
        throw new Error('Namespace must be a non-empty string');
      }

      const timestamp = new Date().toISOString();
      
      // Generate the file content
      const fileContent = `// RAG Namespace Storage
// This file stores the namespace used for RAG embeddings
// Auto-generated by trainModel - DO NOT EDIT MANUALLY

module.exports = {
  namespace: '${namespace.replace(/'/g, "\\'")}',
  indexName: '${(indexName || '').replace(/'/g, "\\'")}',
  lastUpdated: '${timestamp}'
};
`;

      // Write to file
      await fs.writeFile(NAMESPACE_FILE, fileContent, 'utf8');
      
      logger.info(`Saved namespace "${namespace}" to ${NAMESPACE_FILE}`);
      return true;
    } catch (error) {
      logger.error('Error saving namespace to file:', error);
      throw new Error(`Failed to save namespace: ${error.message}`);
    }
  }

  /**
   * Clear namespace from storage (set to null)
   * @returns {Promise<boolean>} True if cleared successfully
   */
  async clearNamespace() {
    try {
      const fileContent = `// RAG Namespace Storage
// This file stores the namespace used for RAG embeddings
// Auto-generated by trainModel - DO NOT EDIT MANUALLY

module.exports = {
  namespace: null,
  indexName: null,
  lastUpdated: null
};
`;

      await fs.writeFile(NAMESPACE_FILE, fileContent, 'utf8');
      logger.info('Cleared namespace from storage file');
      return true;
    } catch (error) {
      logger.error('Error clearing namespace:', error);
      throw new Error(`Failed to clear namespace: ${error.message}`);
    }
  }

  /**
   * Get namespace with fallback to env
   * @returns {Promise<string>} Namespace string
   */
  async getNamespaceWithFallback() {
    const storedNamespace = await this.getNamespace();
    if (storedNamespace) {
      return storedNamespace;
    }
    
    // Fallback to env
    const { PINECONE_DEFAULT_NAMESPACE } = require('../config/pinecone');
    return PINECONE_DEFAULT_NAMESPACE || 'default';
  }
}

module.exports = new NamespaceManager();

